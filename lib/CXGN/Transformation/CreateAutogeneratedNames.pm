package CXGN::Transformation::CreateAutogeneratedNames;

=head1 NAME

CXGN::Transformation::CreateAutogeneratedNames - a module to create autogenerated names based on autogenerated name metadata.

=head1 USAGE


=head1 DESCRIPTION


=head1 AUTHORS

Titima Tantikanjana (tt15@cornell.edu)

=cut

use Moose;
use MooseX::FollowPBP;
use Moose::Util::TypeConstraints;
use Try::Tiny;
use CXGN::Stock::StockLookup;
use SGN::Model::Cvterm;
use Data::Dumper;
use JSON;

has 'schema' => (
    is => 'rw',
    isa => 'DBIx::Class::Schema',
	predicate => 'has_schema',
	required => 1,
);

has 'dbh' => (
    is  => 'rw',
    predicate => 'has_dbh',
    required => 1,
);

has 'breeding_program_id' => (
    isa =>'Int',
    is => 'rw',
    predicate => 'has_breeding_program_id',
    required => 1,
);

has 'name_format' => (
    isa =>'Str',
    is => 'rw',
    predicate => 'has_name_format',
    required => 1,
);

has 'number_of_names' => (
    isa => 'Int',
    is => 'rw',
    predicate => 'has_number_of_names',
    required => 1,
);

has 'source_info' => (
    isa => 'Str',
    is => 'rw',
    predicate => 'has_source_info',
    required => 1,
);


sub create_names {

    my $self = shift;
    my $schema = $self->get_schema();
    my $breeding_program_id = $self->get_breeding_program_id();
    my $name_format = $self->get_name_format();
    my $number_of_names = $self->get_number_of_names();
    my $source_info_string = $self->get_source_info();
    my $source_info = decode_json $source_info_string;

    my @autogenerated_names;
    my $name_metadata_hash = {};

    my $autogenerated_name_metadata_cvterm = SGN::Model::Cvterm->get_cvterm_row($schema, 'autogenerated_name_metadata', 'project_property');
    my $program = $schema->resultset('Project::Project')->find({ project_id => $breeding_program_id});
    if (!$program) {
        return {error => "Breeding Program not found!\n"};
    }

    my $name_metadata_projectprop_rs = $program->projectprops({type_id => $autogenerated_name_metadata_cvterm->cvterm_id});
    if ($name_metadata_projectprop_rs->count == 1){
        my $name_metadata_string = $name_metadata_projectprop_rs->first->value();
        $name_metadata_hash = decode_json $name_metadata_string;
    } else {
        return {error => "Error retrieving autogenerated name metadata!\n"};
    }
    my $name_format_metadata = $name_metadata_hash->{$name_format};
    my $name_attributes = $name_format_metadata->{'name_attributes'};
    my $last_serial_number = $name_format_metadata->{'last_serial_number'};

    my @new_autogenerated_names;
    my $prefix;
    foreach my $n (1..$number_of_names) {
        my @all_name_components = ();
        my $new_name = '';
        my $incremented_number = $n + $last_serial_number;
        foreach my $attribute (@$name_attributes) {
            my $name_info;
            my %text_hash = ();
            if (ref $attribute eq ref {}) {
                %text_hash = %{$attribute};
                $name_info = $text_hash{'text'};
                push @all_name_components, $name_info;
            } else {
                $name_info = $source_info->{$attribute};
                push @all_name_components, $name_info;
            }
        }
        $new_name = join("_", @all_name_components).$incremented_number;
        push @new_autogenerated_names, $new_name;
    }

    my $rs = $schema->resultset("Stock::Stock")->search({
        'is_obsolete' => { '!=' => 't' },
        'uniquename' => { -in => \@new_autogenerated_names }
    });

    my @invalid_names = ();
    while (my $r=$rs->next){
        push @invalid_names, $r->uniquename;
    }

    if (scalar(@invalid_names) >= 1) {
        my $names = join(",", @invalid_names);
        return {error => "Invalid Names: $names!\n"};
    }

    my $new_last_serial_number = $last_serial_number + $number_of_names;

    my $new_names_info = {};
    $new_names_info->{'new_autogenerated_names'} = \@new_autogenerated_names;
    $new_names_info->{'new_last_serial_number'} = $new_last_serial_number;

    return {new_names => $new_names_info};

}



#######
1;
#######
