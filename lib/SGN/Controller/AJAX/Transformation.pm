package SGN::Controller::AJAX::Transformation;

use Moose;
use Data::Dumper;
use JSON;
use CXGN::People::Person;
use SGN::Image;
use CXGN::Stock::StockLookup;
use CXGN::Stock::ParseUpload;
use CXGN::Location::LocationLookup;
use SGN::Model::Cvterm;
use CXGN::List::Validate;
use CXGN::List;
use CXGN::Transformation::AddTransformationProject;
use CXGN::Transformation::AddTransformationIdentifier;
use CXGN::Transformation::Transformation;
use CXGN::Transformation::AddTransformant;
use CXGN::TrackingActivity::AddActivityProject;
use CXGN::TrackingActivity::AddTrackingIdentifier;
use CXGN::Transformation::AddAutogeneratedNameMetadata;
use CXGN::Transformation::CreateAutogeneratedNames;
use CXGN::TrackingActivity::ActivityInfo;
use CXGN::BreedersToolbox::Projects;
use CXGN::Transformation::Transformant;
use DateTime;
use List::MoreUtils qw /any /;


BEGIN { extends 'Catalyst::Controller::REST' }

__PACKAGE__->config(
    default   => 'application/json',
    stash_key => 'rest',
    map       => { 'application/json' => 'JSON', 'text/html' => 'JSON' },
   );


sub add_transformation_project : Path('/ajax/transformation/add_transformation_project') : ActionClass('REST') {}

sub add_transformation_project_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $project_name = $c->req->param('project_name');
    my $breeding_program_id = $c->req->param('project_program_id');
    my $location = $c->req->param('project_location');
    my $year = $c->req->param('year');
    my $project_description = $c->req->param('project_description');
    $project_name =~ s/^\s+|\s+$//g;

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to add a transformation project." };
        return;
    }

    my $program_name = $schema->resultset('Project::Project')->find({project_id => $breeding_program_id})->name();
    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to add new transformation project." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $geolocation_lookup = CXGN::Location::LocationLookup->new(schema =>$schema);
       $geolocation_lookup->set_location_name($location);
       if(!$geolocation_lookup->get_geolocation()){
           $c->stash->{rest}={error => "Location not found"};
           return;
       }

    my $error;
    my $return;
    my $transformation_project_id;
    eval{
        my $add_transformation_project = CXGN::Transformation::AddTransformationProject->new({
            chado_schema => $schema,
            dbh => $dbh,
            breeding_program_id => $breeding_program_id,
            year => $year,
            project_description => $project_description,
            transformation_project_name => $project_name,
            nd_geolocation_id => $geolocation_lookup->get_geolocation()->nd_geolocation_id(),
            owner_id => $user_id
        });

        $return = $add_transformation_project->save_transformation_project();
    };

    if (!$return){
        $c->stash->{rest} = {error => "Error saving project",};
        return;
    }

    if ($return->{error}){
        $error = $return->{error};
        $c->stash->{rest}={error => $error};
        return;
    } else {
        $transformation_project_id = $return->{project_id};
    }


    if ($@) {
        $c->stash->{rest} = {error => $@};
        return;
    };

    my $tracking_transformation = $c->config->{tracking_transformation};
    if ($tracking_transformation) {
        my $tracking_project_name = $project_name."_"."progress";

        my $add_tracking_project = CXGN::TrackingActivity::AddActivityProject->new({
            bcs_schema => $schema,
            dbh => $dbh,
            breeding_program_id => $breeding_program_id,
            year => $year,
            project_description => "Tracking transformation progress for $project_name",
            activity_project_name => $tracking_project_name,
            activity_type => 'transformation',
            nd_geolocation_id => $geolocation_lookup->get_geolocation()->nd_geolocation_id(),
            owner_id => $user_id,
            progress_of_project_id => $transformation_project_id,
        });

        my $return = $add_tracking_project->save_activity_project();
        if (!$return){
            $c->stash->{rest} = {error => "Error saving project",};
            return;
        }

        if ($return->{error}){
            $error = $return->{error};
            $c->stash->{rest} = {error => $error};
            return;
        }
    }

    $c->stash->{rest} = {success => 1};

}


sub add_transformation_identifier : Path('/ajax/transformation/add_transformation_identifier') : ActionClass('REST') {}

sub add_transformation_identifier_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $phenome_schema = $c->dbic_schema("CXGN::Phenome::Schema");
    my $dbh = $c->dbc->dbh;
    my $transformation_identifier = $c->req->param('transformation_identifier');
    my $plant_material = $c->req->param('plant_material');
    my $vector_construct = $c->req->param('vector_construct');
    my $notes = $c->req->param('notes');
    my $program_name = $c->req->param('program_name');
    my $transformation_project_id = $c->req->param('transformation_project_id');
    my $is_a_control = $c->req->param('is_a_control');
    $transformation_identifier =~ s/^\s+|\s+$//g;

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to add a transformation ID." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to add transformation identifiers." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $accession_cvterm_id = SGN::Model::Cvterm->get_cvterm_row($schema,'accession', 'stock_type')->cvterm_id();
    my $vector_construct_cvterm_id = SGN::Model::Cvterm->get_cvterm_row($schema,'vector_construct', 'stock_type')->cvterm_id();

    if ($schema->resultset("Stock::Stock")->find({uniquename => $transformation_identifier})){
        $c->stash->{rest} = {error =>  "Transformation ID already exists. Please use another name" };
        return;
    }

    if (! $schema->resultset("Stock::Stock")->find({uniquename => $plant_material, type_id => $accession_cvterm_id })){
        $c->stash->{rest} = {error =>  "Plant material does not exist or does not exist as accession uniquename." };
        return;
    }

    if (! $schema->resultset("Stock::Stock")->find({uniquename => $vector_construct, type_id => $vector_construct_cvterm_id })){
        $c->stash->{rest} = {error =>  "vector construct does not exist or does not exist as vector construct uniquename." };
        return;
    }

    my $transformation_stock_id;
    eval {
        my $add_transformation = CXGN::Transformation::AddTransformationIdentifier->new({
            chado_schema => $schema,
            phenome_schema => $phenome_schema,
            dbh => $dbh,
            transformation_project_id => $transformation_project_id,
            transformation_identifier => $transformation_identifier,
            plant_material => $plant_material,
            vector_construct => $vector_construct,
            notes => $notes,
            owner_id => $user_id,
            is_a_control => $is_a_control
        });

        my $add = $add_transformation->add_transformation_identifier();
        $transformation_stock_id = $add->{transformation_id};
    };

    if ($@) {
        $c->stash->{rest} = { success => 0, error => $@ };
        print STDERR "An error condition occurred, was not able to create transformation ID. ($@).\n";
        return;
    }

    my $tracking_transformation = $c->config->{tracking_transformation};

    if ($tracking_transformation && $transformation_stock_id) {
        my $progress_of_cvterm_id = SGN::Model::Cvterm->get_cvterm_row($schema,'progress_of', 'project_relationship')->cvterm_id();
        my $project_rel_row = $schema->resultset('Project::ProjectRelationship')->find({object_project_id => $transformation_project_id, type_id => $progress_of_cvterm_id });
        my $tracking_project_id = $project_rel_row->subject_project_id;
        my $tracking_identifier = 'Tracking_'.$transformation_identifier;

        my $tracking_obj = CXGN::TrackingActivity::AddTrackingIdentifier->new({
            schema => $schema,
            phenome_schema => $phenome_schema,
            tracking_identifier => $tracking_identifier,
            material => $transformation_identifier,
            project_id => $tracking_project_id,
            user_id => $user_id
        });

        my $return = $tracking_obj->store();
        if (!$return){
            $c->stash->{rest} = {error => "Error generating tracking identifier",};
            return;
        } elsif ($return->{error}) {
            my $error = $return->{error};
            $c->stash->{rest} = {error => $error};
            return;
        }
    }

    $c->stash->{rest} = { success => 1 };

}


sub upload_transformation_identifiers : Path('/ajax/transformation/upload_transformation_identifiers') : ActionClass('REST'){ }

sub upload_transformation_identifiers_POST : Args(0) {
    my $self = shift;
    my $c = shift;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $metadata_schema = $c->dbic_schema("CXGN::Metadata::Schema");
    my $phenome_schema = $c->dbic_schema("CXGN::Phenome::Schema");
    my $dbh = $c->dbc->dbh;
    my $transformation_project_id = $c->req->param('transformation_project_id');
    my $upload = $c->req->upload('transformation_ids_file');
    my $parser;
    my $parsed_data;
    my $upload_original_name = $upload->filename();
    my $upload_tempfile = $upload->tempname;
    my $subdirectory = "transformation_identifiers_upload";
    my $archived_filename_with_path;
    my $md5;
    my $validate_file;
    my $parsed_file;
    my $parse_errors;
    my %parsed_data;
    my $time = DateTime->now();
    my $timestamp = $time->ymd()."_".$time->hms();
    my $user_role;
    my $user_id;
    my $user_name;
    my $owner_name;
    my $session_id = $c->req->param("sgn_session_id");
    my @error_messages;

    if ($session_id){
        my $dbh = $c->dbc->dbh;
        my @user_info = CXGN::Login->new($dbh)->query_from_cookie($session_id);
        if (!$user_info[0]){
            $c->stash->{rest} = {error=>'You must be logged in to upload transformation identifers!'};
            $c->detach();
        }
        $user_id = $user_info[0];
        $user_role = $user_info[1];
        my $p = CXGN::People::Person->new($dbh, $user_id);
        $user_name = $p->get_username;
    } else {
        if (!$c->user){
            $c->stash->{rest} = {error=>'You must be logged in to upload transformation identifiers!'};
            $c->detach();
        }
        $user_id = $c->user()->get_object()->get_sp_person_id();
        $user_name = $c->user()->get_object()->get_username();
        $user_role = $c->user->get_object->get_user_type();
    }

    if (($user_role ne 'curator') && ($user_role ne 'submitter')) {
        $c->stash->{rest} = {error=>'Only a submitter or a curator can upload transformation identifiers'};
        $c->detach();
    }

    my $program_object = CXGN::BreedersToolbox::Projects->new( { schema => $schema });
    my $program_ref = $program_object->get_breeding_programs_by_trial($transformation_project_id);

    my $program_array = @$program_ref[0];
    my $breeding_program_name = @$program_array[1];
    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$breeding_program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
      $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $breeding_program_name to upload transformation identifiers." };
      return;
    }


    my $uploader = CXGN::UploadFile->new({
        tempfile => $upload_tempfile,
        subdirectory => $subdirectory,
        archive_path => $c->config->{archive_path},
        archive_filename => $upload_original_name,
        timestamp => $timestamp,
        user_id => $user_id,
        user_role => $user_role
    });

        ## Store uploaded temporary file in arhive
    $archived_filename_with_path = $uploader->archive();
    $md5 = $uploader->get_md5($archived_filename_with_path);
    if (!$archived_filename_with_path) {
        $c->stash->{rest} = {error => "Could not save file $upload_original_name in archive",};
        return;
    }
    unlink $upload_tempfile;

    #parse uploaded file with appropriate plugin
    my @stock_props = ('transformation_notes');
    $parser = CXGN::Stock::ParseUpload->new(chado_schema => $schema, filename => $archived_filename_with_path, editable_stock_props=>\@stock_props);

    $parser->load_plugin('TransformationIdentifiersGeneric');
    $parsed_data = $parser->parse();
    #print STDERR "PARSED DATA =". Dumper($parsed_data)."\n";
    if (!$parsed_data){
        my $return_error = '';
        my $parse_errors;
        if (!$parser->has_parse_errors() ){
            $c->stash->{rest} = {error_string => "Could not get parsing errors"};
        } else {
            $parse_errors = $parser->get_parse_errors();
            #print STDERR Dumper $parse_errors;
            foreach my $error_string (@{$parse_errors->{'error_messages'}}){
                $return_error .= $error_string."<br>";
            }
        }
        $c->stash->{rest} = {error_string => $return_error};
        $c->detach();
    }

    if ($parsed_data){
        eval {
            foreach my $row (keys %$parsed_data) {
                my $transformation_identifier = $parsed_data->{$row}->{'transformation_identifier'};
                my $accession_name = $parsed_data->{$row}->{'accession_name'};
                my $vector_construct = $parsed_data->{$row}->{'vector_construct'};
                my $notes = $parsed_data->{$row}->{'notes'};
                my $add_transformation = CXGN::Transformation::AddTransformationIdentifier->new({
                    chado_schema => $schema,
                    phenome_schema => $phenome_schema,
                    dbh => $dbh,
                    transformation_project_id => $transformation_project_id,
                    transformation_identifier => $transformation_identifier,
                    plant_material => $accession_name,
                    vector_construct => $vector_construct,
                    notes => $notes,
                    owner_id => $user_id,
                });

                $add_transformation->add_transformation_identifier();
            }
        };

        if ($@) {
            $c->stash->{rest} = { success => 0, error => $@ };
            print STDERR "An error condition occurred, was not able to create transformation ID. ($@).\n";
            return;
        }
    }


    $c->stash->{rest} = {success => "1",};
}


sub get_active_transformations_in_project :Path('/ajax/transformation/active_transformations_in_project') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $project_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, project_id=>$project_id});

    my $result = $transformation_obj->get_active_transformations_in_project();

    my @transformations;
    foreach my $r (@$result){
        my ($transformation_id, $transformation_name, $plant_id, $plant_name, $vector_id, $vector_name, $notes, $is_a_control, $control_id, $control_name) =@$r;
        my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
        my $transformants = $transformation_obj->transformants();
        my $number_of_transformants = scalar(@$transformants);
        my $control_column_info;
        if($is_a_control) {
            $control_column_info = 'is a control';
        } elsif ($control_id) {
            $control_column_info = qq{<a href="/transformation/$control_id">$control_name</a>};
        }
        push @transformations, [qq{<a href="/transformation/$transformation_id">$transformation_name</a>}, qq{<a href="/stock/$plant_id/view">$plant_name</a>}, qq{<a href="/stock/$vector_id/view">$vector_name</a>}, $notes, $control_column_info, $number_of_transformants];
    }

    $c->stash->{rest} = { data => \@transformations };

}


sub get_inactive_transformation_ids_in_project :Path('/ajax/transformation/inactive_transformation_ids_in_project') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $project_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, project_id=>$project_id});

    my $result = $transformation_obj->get_inactive_transformations_in_project();

    my @transformations;
    foreach my $r (@$result){
        my ($transformation_id, $transformation_name, $plant_id, $plant_name, $vector_id, $vector_name, $notes, $is_a_control, $control_id, $control_name, $status_type) =@$r;

        if ($status_type eq 'terminated_metadata') {
            $status_type = '<span style="color:red">'.'TERMINATED'.'</span>';
        } elsif ($status_type eq 'completed_metadata') {
            $status_type = '<span style="color:red">'.'COMPLETED'.'</span>';
        }
        my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
        my $transformants = $transformation_obj->transformants();
        my $number_of_transformants = scalar(@$transformants);

        my $control_column_info;
        if ($is_a_control) {
            $control_column_info = 'is a control';
        } elsif ($control_id) {
            $control_column_info = qq{<a href="/transformation/$control_id">$control_name</a>}
        }

        push @transformations, [qq{<a href="/transformation/$transformation_id">$transformation_name</a>}, $status_type, qq{<a href="/stock/$plant_id/view">$plant_name</a>}, qq{<a href="/stock/$vector_id/view">$vector_name</a>}, $notes, $control_column_info, $number_of_transformants];
    }

    $c->stash->{rest} = { data => \@transformations };

}


sub add_transformants : Path('/ajax/transformation/add_transformants') : ActionClass('REST') {}

sub add_transformants_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $phenome_schema = $c->dbic_schema("CXGN::Phenome::Schema");
    my $dbh = $c->dbc->dbh;
    my $transformation_stock_id = $c->req->param('transformation_stock_id');
    my $new_name_count = $c->req->param('new_name_count');
    my $last_number = $c->req->param('last_number');
    my $name_format = $c->req->param('name_format');
    my $program_id = $c->req->param('program_id');
    my $program_name = $c->req->param('program_name');
    my $source_info = $c->req->param('source_info');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to add new transformants." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to add new transformants." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $autogenerated_names = CXGN::Transformation::CreateAutogeneratedNames->new({schema => $schema, dbh => $dbh, breeding_program_id => $program_id, name_format => $name_format, number_of_names => $new_name_count, source_info => $source_info });
    my $return = $autogenerated_names->create_names();
    if (!$return){
        $c->stash->{rest} = {error => "Error generating transformant names"};
        return;
    } elsif ($return->{error}) {
        $c->stash->{rest} = {error => $return->{error}};
        return;
    }

    my $new_names_info = $return->{new_names};
    my $new_names = $new_names_info->{'new_autogenerated_names'};
    my $new_last_serial_number = $new_names_info->{'new_last_serial_number'};

    eval {
        my $add_transformants = CXGN::Transformation::AddTransformant->new({
            schema => $schema,
            phenome_schema => $phenome_schema,
            dbh => $dbh,
            transformation_stock_id => $transformation_stock_id,
            transformant_names => $new_names,
            owner_id => $user_id,
        });

        $add_transformants->add_transformant();
    };

    if ($@) {
        $c->stash->{rest} = { success => 0, error => $@ };
        print STDERR "An error condition occurred, was not able to create new transformants. ($@).\n";
        return;
    }

    my $name_metadata_cvterm = SGN::Model::Cvterm->get_cvterm_row($schema, 'autogenerated_name_metadata', 'project_property');
    my $program = $schema->resultset('Project::Project')->find({ project_id => $program_id});
    my $metadata_projectprop_rs = $program->projectprops({type_id => $name_metadata_cvterm->cvterm_id});
    if ($metadata_projectprop_rs->count == 1){
        my $stored_name_metadata_string = $metadata_projectprop_rs->first->value();
        my $name_metadata_hash = decode_json $stored_name_metadata_string;
        $name_metadata_hash->{$name_format}->{'last_serial_number'} = $new_last_serial_number;
        my $new_name_metadata_string = encode_json $name_metadata_hash;
        $metadata_projectprop_rs->first->update({value=>$new_name_metadata_string});
    }

    my $tracking_transformation = $c->config->{tracking_transformation};
    if ($tracking_transformation) {
        my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id});
        my $tracking_identifier = $transformation_obj->tracking_identifier();
        my $tracking_identifier_name = $tracking_identifier->[0]->[1];

        my $time = DateTime->now();
        my $timestamp = $time->ymd()."_".$time->hms();

        my $add_activity_info = CXGN::TrackingActivity::ActivityInfo->new({
            schema => $schema,
            tracking_identifier => $tracking_identifier_name,
            selected_type => 'number_of_transformants',
            input => $new_name_count,
            timestamp => $timestamp,
            operator_id => $user_id,
            notes => 'Entry from transformation page',
            activity_type => 'transformation'
        });
        my $return = $add_activity_info->add_info();
        if (!$return){
            $c->stash->{rest} = {error => "Error saving tracking information"};
            return;
        } elsif ($return->{error}) {
            $c->stash->{rest} = {error => $return->{error}};
            return;
        }
    }

    $c->stash->{rest} = { success => 1 };

}


sub add_transformants_using_list : Path('/ajax/transformation/add_transformants_using_list') : ActionClass('REST'){ }

sub add_transformants_using_list_POST : Args(0) {
    my $self = shift;
    my $c = shift;
    my $program_name = $c->req->param("program_name");

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!($c->user()->has_role('submitter') or $c->user()->has_role('curator'))) {
        $c->stash->{rest} = { error_string => "You do not have sufficient privileges to add new transformants." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to add new transformants." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $phenome_schema = $c->dbic_schema("CXGN::Phenome::Schema");
    my $dbh = $c->dbc->dbh();
    my @error_messages;

    my $transformation_name = $c->req->param("transformation_name");
    my $list_id = $c->req->param("list_id");

    my $transformation_type_id = SGN::Model::Cvterm->get_cvterm_row($schema, 'transformation', 'stock_type')->cvterm_id();
    my $transformation_stock_id;
    my $transformation_identifier_rs = $schema->resultset("Stock::Stock")->find( { uniquename => $transformation_name, type_id => $transformation_type_id });
    if (!$transformation_identifier_rs) {
        $c->stash->{rest} = { error_string => "Error! Transformation Identifier: $transformation_name was not found in the database.\n" };
        return;
    } else {
        $transformation_stock_id = $transformation_identifier_rs->stock_id();
    }

    my $list = CXGN::List->new( { dbh=>$dbh, list_id=>$list_id });
    my $new_transformant_names = $list->elements();

    my $rs = $schema->resultset("Stock::Stock")->search({
        'is_obsolete' => { '!=' => 't' },
        'uniquename' => { -in => $new_transformant_names }
    });
    while (my $r=$rs->next){
        push @error_messages, "Transformant name already exists in database: ".$r->uniquename;
    }

    if (scalar(@error_messages) >= 1) {
        my $return_error = '';
        foreach my $error_string (@error_messages){
            $return_error .= $error_string."<br>";
        }
        $c->stash->{rest} = { error_string => $return_error};
        return;
    }

    eval {
        my $add_transformants = CXGN::Transformation::AddTransformant->new({
            schema => $schema,
            phenome_schema => $phenome_schema,
            dbh => $dbh,
            transformation_stock_id => $transformation_stock_id,
            transformant_names => $new_transformant_names,
            owner_id => $user_id,
        });

        $add_transformants->add_transformant();
    };

    if ($@) {
        $c->stash->{rest} = { success => 0, error => $@ };
        print STDERR "An error condition occurred, was not able to create new transformants. ($@).\n";
        return;
    }

    $c->stash->{rest} = { success => 1 };

}


sub get_transformants :Path('/ajax/transformation/transformants') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $transformation_stock_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id});

    my $result = $transformation_obj->transformants();

    my @transformants;
    foreach my $r (@$result){
        my ($stock_id, $stock_name) =@$r;
        push @transformants, {
            transformant_id => $stock_id,
            transformant_name => $stock_name,
        };
    }

    $c->stash->{rest} = { data => \@transformants };

}


sub get_obsoleted_transformants :Path('/ajax/transformation/obsoleted_transformants') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $transformation_stock_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id});

    my $result = $transformation_obj->obsoleted_transformants();

    my @obsoleted_transformants;
    foreach my $r (@$result){
        my ($stock_id, $stock_name, $obsolete_note, $obsolete_date, $sp_person_id) =@$r;
        my $person= CXGN::People::Person->new($dbh, $sp_person_id);
        my $full_name = $person->get_first_name()." ".$person->get_last_name();

        push @obsoleted_transformants, {
            transformant_id => $stock_id,
            transformant_name => $stock_name,
            obsolete_note => $obsolete_note,
            obsolete_date => $obsolete_date,
            obsolete_person => $full_name
        };
    }

    $c->stash->{rest} = { data => \@obsoleted_transformants };

}


sub set_autogenerated_name_format : Path('/ajax/transformation/set_autogenerated_name_format') : ActionClass('REST') {}

sub set_autogenerated_name_format_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $project_id = $c->req->param('project_id');
    my $name_format = $c->req->param('name_format');
    my $program_name = $c->req->param('program_name');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to set autogenerated name format for this project." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to set autogenerated name format for new transformants." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $autogenerated_name_format_cvterm = SGN::Model::Cvterm->get_cvterm_row($schema, 'autogenerated_name_format', 'project_property');

    my $project = $schema->resultset('Project::Project')->find({ project_id => $project_id});
    if (!$project) {
        print STDERR "Project not found!\n";
        return;
    }
    my $projectprop_rs = $project->projectprops({type_id => $autogenerated_name_format_cvterm->cvterm_id});
    if ($projectprop_rs->count == 1){
        $projectprop_rs->first->update({value=>$name_format});
    } elsif ($projectprop_rs->count > 1) {
        print STDERR "More than one found!\n";
        return;
    } else {
        $project->create_projectprops({$autogenerated_name_format_cvterm->name() => $name_format});
    }

    $c->stash->{rest} = { success => 1 };

}


sub set_default_plant_material : Path('/ajax/transformation/set_default_plant_material') : ActionClass('REST') {}

sub set_default_plant_material_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $project_id = $c->req->param('transformation_project_id');
    my $default_plant_material_name = $c->req->param('default_plant_material');
    my $program_name = $c->req->param('program_name');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to set default plant material for this project." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to set default plant material for transformation." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $accession_cvterm_id = SGN::Model::Cvterm->get_cvterm_row($schema,'accession', 'stock_type')->cvterm_id();
    my $default_plant_material_cvterm = SGN::Model::Cvterm->get_cvterm_row($schema, 'default_plant_material', 'project_property');

    my $plant_material_stock_id;
    my $plant_material_rs = $schema->resultset("Stock::Stock")->find({uniquename => $default_plant_material_name, type_id => $accession_cvterm_id });
    if (!$plant_material_rs){
        $c->stash->{rest} = {error =>  "Plant material does not exist or does not exist as accession uniquename." };
        return;
    } else {
        $plant_material_stock_id = $plant_material_rs->stock_id();
    }

    my $project = $schema->resultset('Project::Project')->find({ project_id => $project_id});
    if (!$project) {
        print STDERR "Project not found!\n";
        return;
    }
    my $projectprop_rs = $project->projectprops({type_id => $default_plant_material_cvterm->cvterm_id});
    if ($projectprop_rs->count == 1){
        $projectprop_rs->first->update({value=>$plant_material_stock_id});
    } elsif ($projectprop_rs->count > 1) {
        print STDERR "More than one found!\n";
        return;
    } else {
        $project->create_projectprops({$default_plant_material_cvterm->name() => $plant_material_stock_id});
    }


    $c->stash->{rest} = { success => 1 };

}


sub add_autogenerated_name_metadata : Path('/ajax/transformation/add_autogenerated_name_metadata') : ActionClass('REST') {}

sub add_autogenerated_name_metadata_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $phenome_schema = $c->dbic_schema("CXGN::Phenome::Schema");
    my $dbh = $c->dbc->dbh;
    my $breeding_program_id = $c->req->param('breeding_program');
    my $format_name = $c->req->param('format_name');
    my $description = $c->req->param('description');
    my $name_type = $c->req->param('name_type');
    my $name_attributes_json = $c->req->param('name_attributes');
    my $name_attributes = decode_json $name_attributes_json;

    my $last_serial_number = $c->req->param('last_serial_number');

    my $time = DateTime->now();
    my $date = $time->ymd();

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to add new autogenerated name metadata." };
        return;
    }

    my $program_name = $schema->resultset('Project::Project')->find({project_id => $breeding_program_id})->name();
    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to add autogenerated name metadata." };
        return;
    }

    my $user_id = $c->user()->get_object()->get_sp_person_id();

    my $add_autogenerated_name_metadata = CXGN::Transformation::AddAutogeneratedNameMetadata->new({
        schema => $schema,
        dbh => $dbh,
        breeding_program_id => $breeding_program_id,
        format_name => $format_name,
        description => $description,
        name_type => $name_type,
        name_attributes => $name_attributes,
        last_serial_number => $last_serial_number,
        added_by => $user_id,
        date => $date
    });

    my $return = $add_autogenerated_name_metadata->add_info();

    if ($return->{error}) {
        $c->stash->{rest} = {error => $return->{error}};
        return;
    }

    $c->stash->{rest} = { success => 1 };

}


sub get_all_transformation_ids_in_project :Path('/ajax/transformation/all_transformation_ids_in_project') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $project_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, project_id=>$project_id});

    my $active_transformations = $transformation_obj->get_active_transformations_in_project();
    my $inactive_transformations = $transformation_obj->get_inactive_transformations_in_project();

    my @transformations;
    foreach my $active_id (@$active_transformations){
        my $transformation_id = $active_id->[0];
        my $transformation_name = $active_id->[1];
        my $status_type = 'ACTIVE';
        my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
        my $transformants = $transformation_obj->transformants();
        my $number_of_transformants = scalar(@$transformants);
        push @transformations, {
            transformation_id => $transformation_id,
            transformation_name => $transformation_name,
            status_type => $status_type,
            number_of_transformants => $number_of_transformants
        };
    }

    foreach my $inactive_id (@$inactive_transformations){
        my $transformation_id = $inactive_id->[0];
        my $transformation_name = $inactive_id->[1];
        my $status_type = $inactive_id->[7];
        my $status_display;
        if ($status_type eq 'completed_metadata') {
            $status_display = 'COMPLETED';
        } elsif ($status_type eq 'terminated_metadata') {
            $status_display = 'TERMINATED';
        }
        my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
        my $transformants = $transformation_obj->transformants();
        my $number_of_transformants = scalar(@$transformants);
        push @transformations, {
            transformation_id => $transformation_id,
            transformation_name => $transformation_name,
            status_type => $status_display,
            number_of_transformants => $number_of_transformants
        };
    }

    $c->stash->{rest} = { data => \@transformations };

}


sub delete_transformation_id : Path('/ajax/transformation/delete') : ActionClass('REST') {}

sub delete_transformation_id_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $transformation_stock_id = $c->req->param('transformation_stock_id');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!$c->user()->check_roles("curator")) {
        $c->stash->{rest} = { error => "You do not have the correct role to delete transformation ID. Please contact us." };
        $c->detach();
    }

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id});
    my $error = $transformation_obj->delete();

    if ($error) {
	    $c->stash->{rest} = { error => "An error occurred attempting to delete the transformation ID. ($@)" };
	    return;
    }

    $c->stash->{rest} = { success => 1 };
}


sub set_transformation_control : Path('/ajax/transformation/set_transformation_control') : ActionClass('REST') {}

sub set_transformation_control_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $transformation_stock_id = $c->req->param('transformation_stock_id');
    my $control_stock_id = $c->req->param('control_stock_id');
    my $program_name = $c->req->param('program_name');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to set a control for this transformation ID." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to set a control for this transformation ID." };
        return;
    }

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id, transformation_control_stock_id=>$control_stock_id});
    my $error = $transformation_obj->set_transformation_control();
    if ($error) {
	    $c->stash->{rest} = { error => "An error occurred attempting to set transformation control. ($@)" };
	    return;
    }

    $c->stash->{rest} = { success => 1 };

}


sub set_as_control : Path('/ajax/transformation/set_as_control') : ActionClass('REST') {}

sub set_as_control_POST :Args(0){
    my ($self, $c) = @_;
    my $schema = $c->dbic_schema('Bio::Chado::Schema', 'sgn_chado');
    my $dbh = $c->dbc->dbh;
    my $transformation_stock_id = $c->req->param('transformation_id');
    my $is_a_control = $c->req->param('is_a_control');
    my $program_name = $c->req->param('program_name');

    if (!$c->user()) {
        $c->res->redirect( uri( path => '/user/login', query => { goto_url => $c->req->uri->path_query } ) );
        return;
    }

    if (!any { $_ eq "curator" || $_ eq "submitter" } ($c->user()->roles)){
        $c->stash->{rest} = {error =>  "you have insufficient privileges to set this transformation ID as a control." };
        return;
    }

    my @user_roles = $c->user->roles();
    my %has_roles = ();
    map { $has_roles{$_} = 1; } @user_roles;

    if (! ( (exists($has_roles{$program_name}) && exists($has_roles{submitter})) || exists($has_roles{curator}))) {
        $c->stash->{rest} = { error => "You need to be either a curator, or a submitter associated with breeding program $program_name to set this transformation ID as a control." };
        return;
    }

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_stock_id, is_a_control=>$is_a_control});
    my $error = $transformation_obj->set_as_control();
    if ($error) {
        $c->stash->{rest} = { error => "An error occurred attempting to set the transformation ID as a control. ($@)" };
        return;
    }

    $c->stash->{rest} = { success => 1 };

}


sub get_tranformant_experiment_info :Path('/ajax/transformation/transformant_experiment_info') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $stock_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformant_obj = CXGN::Transformation::Transformant->new({schema=>$schema, dbh=>$dbh, transformant_stock_id=>$stock_id});
    my $experiment_info = $transformant_obj->get_transformant_experiment_info();
    my $plant_id = $experiment_info->[0]->[0];
    my $plant_name = $experiment_info->[0]->[1];
    my $plant_link = qq{<a href="/stock/$plant_id/view">$plant_name</a>};
    my $vector_id = $experiment_info->[0]->[2];
    my $vector_name = $experiment_info->[0]->[3];
    my $vector_link = qq{<a href="/stock/$vector_id/view">$vector_name</a>};
    my $transformation_id = $experiment_info->[0]->[4];
    my $transformation_name = $experiment_info->[0]->[5];
    my $transformation_link;
    if ($transformation_id) {
        $transformation_link = qq{<a href="/transformation/$transformation_id">$transformation_name</a>};
    }

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
    my $project_info = $transformation_obj->get_associated_projects();
    my $project_id = $project_info->[0]->[0];
    my $project_name = $project_info->[0]->[1];
    my $project_link;
    if ($project_id) {
        $project_link = qq{<a href="/breeders/trial/$project_id">$project_name</a>};
    }

    my @transformant_experiment_info;
    push @transformant_experiment_info, [$plant_link, $vector_link, $transformation_link, $project_link];

    $c->stash->{rest} = { data => \@transformant_experiment_info };

}


sub get_related_transformants :Path('/ajax/transformation/related_transformants') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $transformant_stock_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformant_obj = CXGN::Transformation::Transformant->new({schema=>$schema, dbh=>$dbh, transformant_stock_id=>$transformant_stock_id});
    my $experiment_info = $transformant_obj->get_transformant_experiment_info();
    my $transformation_id = $experiment_info->[0]->[4];

    my $transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$transformation_id});
    my $result = $transformation_obj->transformants();

    my @related_transformants;
    foreach my $r (@$result){
        my ($stock_id, $stock_name) =@$r;
        if ($stock_id != $transformant_stock_id) {
            push @related_transformants, {
                related_transformant_id => $stock_id,
                related_transformant_name => $stock_name,
            };
        }
    }

    $c->stash->{rest} = { data => \@related_transformants };

}


sub get_control_transformants :Path('/ajax/transformation/control_transformants') :Args(1) {
    my $self = shift;
    my $c = shift;
    my $transformant_stock_id = shift;
    my $schema = $c->dbic_schema("Bio::Chado::Schema");
    my $dbh = $c->dbc->dbh;

    my $transformant_obj = CXGN::Transformation::Transformant->new({schema=>$schema, dbh=>$dbh, transformant_stock_id=>$transformant_stock_id});
    my $experiment_info = $transformant_obj->get_transformant_experiment_info();
    my $transformation_id = $experiment_info->[0]->[4];

    my $control_of_type_id = SGN::Model::Cvterm->get_cvterm_row($schema, 'control_of', 'stock_relationship')->cvterm_id();
    my $transformation_control_rs = $schema->resultset("Stock::StockRelationship")->find({ object_id => $transformation_id, type_id => $control_of_type_id});
    my $control_id;
    if ($transformation_control_rs) {
        $control_id = $transformation_control_rs->subject_id();
    }

    my $control_transformation_obj = CXGN::Transformation::Transformation->new({schema=>$schema, dbh=>$dbh, transformation_stock_id=>$control_id});
    my $result = $control_transformation_obj->transformants();

    my @control_transformants;
    foreach my $r (@$result){
        my ($stock_id, $stock_name) =@$r;
        push @control_transformants, {
            control_transformant_id => $stock_id,
            control_transformant_name => $stock_name,
        };
    }

    $c->stash->{rest} = { data => \@control_transformants };

}




###
1;#
###
